// üéÆ Contr√¥leur pour la gestion des produits de la marketplace Geisha Garden
// G√®re toutes les op√©rations CRUD et logique m√©tier des produits

const Product = require('../models/Product');
const ResponseService = require('../services/ResponseService');

class ProductController {
  
  /**
   * üìã R√©cup√©rer tous les produits avec filtres et pagination
   * GET /api/products
   */
  async index(req, res) {
    try {
      const {
        page = 1,
        limit = 12,
        search,
        categoryId,
        minPrice,
        maxPrice,
        sortBy = 'createdAt',
        sortOrder = 'desc',
        inStock = 'true'
      } = req.query;

      const options = {
        page: parseInt(page),
        limit: parseInt(limit),
        sortBy,
        sortOrder: sortOrder === 'desc' ? -1 : 1,
        categoryId,
        minPrice: minPrice ? parseFloat(minPrice) : undefined,
        maxPrice: maxPrice ? parseFloat(maxPrice) : undefined,
        inStock: inStock === 'true'
      };

      const products = await Product.search(search, options);
      const total = await Product.countDocuments({
        isActive: true,
        ...(categoryId && { categoryId }),
        ...(options.minPrice && { price: { $gte: options.minPrice } }),
        ...(options.maxPrice && { price: { $lte: options.maxPrice } }),
        ...(options.inStock && { stock: { $gt: 0 } })
      });

      return ResponseService.success(res, {
        products,
        pagination: {
          current: parseInt(page),
          total: Math.ceil(total / limit),
          count: products.length,
          totalRecords: total
        }
      }, 'Produits r√©cup√©r√©s avec succ√®s');

    } catch (error) {
      return ResponseService.error(res, 'Erreur lors de la r√©cup√©ration des produits', error);
    }
  }

  /**
   * üîç R√©cup√©rer un produit par ID ou slug
   * GET /api/products/:id
   */
  async show(req, res) {
    try {
      const { id } = req.params;
      let product;

      // Recherche par ID MongoDB ou par slug
      if (id.match(/^[0-9a-fA-F]{24}$/)) {
        product = await Product.findById(id)
          .populate('categoryId', 'name slug')
          .populate('vendorId', 'name avatar');
      } else {
        product = await Product.findOne({ 'seo.slug': id })
          .populate('categoryId', 'name slug')
          .populate('vendorId', 'name avatar');
      }

      if (!product || !product.isActive) {
        return ResponseService.notFound(res, 'Produit non trouv√©');
      }

      // Incr√©menter le compteur de vues
      await product.incrementViews();

      return ResponseService.success(res, { product }, 'Produit trouv√©');

    } catch (error) {
      return ResponseService.error(res, 'Erreur lors de la r√©cup√©ration du produit', error);
    }
  }

  /**
   * ‚ú® R√©cup√©rer les produits mis en avant
   * GET /api/products/featured
   */
  async featured(req, res) {
    try {
      const { limit = 8 } = req.query;
      const products = await Product.getFeatured(parseInt(limit));

      return ResponseService.success(res, { products }, 'Produits mis en avant r√©cup√©r√©s');

    } catch (error) {
      return ResponseService.error(res, 'Erreur lors de la r√©cup√©ration des produits mis en avant', error);
    }
  }

  /**
   * üîç Recherche de produits avec autocompl√©tion
   * GET /api/products/search/:query
   */
  async search(req, res) {
    try {
      const { query } = req.params;
      const { limit = 10 } = req.query;

      if (!query || query.length < 2) {
        return ResponseService.badRequest(res, 'La recherche doit contenir au moins 2 caract√®res');
      }

      const products = await Product.find({
        $text: { $search: query },
        isActive: true,
        stock: { $gt: 0 }
      })
      .select('name price images seo.slug')
      .limit(parseInt(limit))
      .sort({ score: { $meta: 'textScore' } });

      return ResponseService.success(res, { products }, `${products.length} r√©sultat(s) trouv√©(s)`);

    } catch (error) {
      return ResponseService.error(res, 'Erreur lors de la recherche', error);
    }
  }

  /**
   * ‚ûï Cr√©er un nouveau produit
   * POST /api/products
   */
  async store(req, res) {
    try {
      const {
        name,
        description,
        price,
        images,
        categoryId,
        vendorId,
        stock,
        tags,
        specifications,
        isFeatured = false
      } = req.body;

      // Validation basique
      if (!name || !description || !price || !images || !categoryId || !vendorId) {
        return ResponseService.badRequest(res, 'Tous les champs obligatoires doivent √™tre renseign√©s');
      }

      if (!Array.isArray(images) || images.length === 0) {
        return ResponseService.badRequest(res, 'Au moins une image est requise');
      }

      const product = new Product({
        name,
        description,
        price: parseFloat(price),
        images,
        categoryId,
        vendorId,
        stock: parseInt(stock) || 0,
        tags: Array.isArray(tags) ? tags : [],
        specifications: specifications || {},
        isFeatured
      });

      await product.save();

      // Peupler les r√©f√©rences pour la r√©ponse
      await product.populate('categoryId', 'name slug');
      await product.populate('vendorId', 'name');

      return ResponseService.created(res, { product }, 'Produit cr√©√© avec succ√®s');

    } catch (error) {
      if (error.name === 'ValidationError') {
        return ResponseService.validationError(res, error);
      }
      return ResponseService.error(res, 'Erreur lors de la cr√©ation du produit', error);
    }
  }

  /**
   * ‚úèÔ∏è Mettre √† jour un produit
   * PUT /api/products/:id
   */
  async update(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;

      // Supprimer les champs non modifiables
      delete updateData._id;
      delete updateData.createdAt;
      delete updateData.updatedAt;
      delete updateData.stats;

      const product = await Product.findByIdAndUpdate(
        id,
        updateData,
        { 
          new: true, 
          runValidators: true 
        }
      )
      .populate('categoryId', 'name slug')
      .populate('vendorId', 'name');

      if (!product) {
        return ResponseService.notFound(res, 'Produit non trouv√©');
      }

      return ResponseService.success(res, { product }, 'Produit mis √† jour avec succ√®s');

    } catch (error) {
      if (error.name === 'ValidationError') {
        return ResponseService.validationError(res, error);
      }
      return ResponseService.error(res, 'Erreur lors de la mise √† jour du produit', error);
    }
  }

  /**
   * üóëÔ∏è Supprimer un produit (soft delete)
   * DELETE /api/products/:id
   */
  async destroy(req, res) {
    try {
      const { id } = req.params;

      const product = await Product.findById(id);
      if (!product) {
        return ResponseService.notFound(res, 'Produit non trouv√©');
      }

      // Soft delete : marquer comme inactif
      product.isActive = false;
      await product.save();

      return ResponseService.success(res, null, 'Produit supprim√© avec succ√®s');

    } catch (error) {
      return ResponseService.error(res, 'Erreur lors de la suppression du produit', error);
    }
  }

  /**
   * üìä Statistiques des produits d'un vendeur
   * GET /api/products/vendor/:vendorId/stats
   */
  async vendorStats(req, res) {
    try {
      const { vendorId } = req.params;

      const stats = await Product.aggregate([
        { $match: { vendorId: mongoose.Types.ObjectId(vendorId), isActive: true } },
        {
          $group: {
            _id: null,
            totalProducts: { $sum: 1 },
            totalViews: { $sum: '$stats.views' },
            totalSales: { $sum: '$stats.sales' },
            averageRating: { $avg: '$stats.rating' },
            totalStock: { $sum: '$stock' }
          }
        }
      ]);

      const result = stats[0] || {
        totalProducts: 0,
        totalViews: 0,
        totalSales: 0,
        averageRating: 0,
        totalStock: 0
      };

      return ResponseService.success(res, { stats: result }, 'Statistiques r√©cup√©r√©es');

    } catch (error) {
      return ResponseService.error(res, 'Erreur lors de la r√©cup√©ration des statistiques', error);
    }
  }

  /**
   * üì¶ Mettre √† jour le stock d'un produit
   * PATCH /api/products/:id/stock
   */
  async updateStock(req, res) {
    try {
      const { id } = req.params;
      const { quantity, operation = 'set' } = req.body; // 'set', 'add', 'subtract'

      if (typeof quantity !== 'number' || quantity < 0) {
        return ResponseService.badRequest(res, 'Quantit√© invalide');
      }

      const product = await Product.findById(id);
      if (!product) {
        return ResponseService.notFound(res, 'Produit non trouv√©');
      }

      switch (operation) {
        case 'add':
          product.stock += quantity;
          break;
        case 'subtract':
          if (product.stock < quantity) {
            return ResponseService.badRequest(res, 'Stock insuffisant');
          }
          product.stock -= quantity;
          break;
        case 'set':
        default:
          product.stock = quantity;
          break;
      }

      await product.save();

      return ResponseService.success(res, { 
        stock: product.stock 
      }, `Stock mis √† jour: ${product.stock} unit√©(s)`);

    } catch (error) {
      return ResponseService.error(res, 'Erreur lors de la mise √† jour du stock', error);
    }
  }
}

module.exports = new ProductController();
